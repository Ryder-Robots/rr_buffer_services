#ifndef RR_SUBSCRIBER_HPP
#define RR_SUBSCRIBER_HPP

#include "rclcpp/rclcpp.hpp"
#include "rr_common_base/rr_state_maintainer.hpp"
#include "rr_common_base/rr_buf_factory.hpp"
#include <functional>
#include <list>
#include <memory>
#include <pluginlib/class_loader.hpp>

namespace rr_buffer_services
{

// plugins to load during initilization.
#define RR_COMMON_BASE "rr_common_base"
#define RR_STATE_MAINTAINER "rrobot::RrStateMaintainer"
#define RR_STATE_MAINTAINER_CLASS rrobot::RrStateMaintainer
#define RR_DEFAULT_STATE_MAINTAINER "rr_common_plugins::RrStateMaintainerImpl"
#define RR_STATE_BUF_FACTORY "rrobot::RrBufFactory"
#define RR_STATE_BUF_FACTORY_CLASS rrobot::RrBufFactory
#define RR_DEFAULT_ROBOT_TYPE "rr_common_plugins::RrBufferFactorySimple"

// CLI arguments
#define RR_CLI_ROBOT_TYPE "robot-type"

/**
 * @class RrController
 * @brief coordinates subscriptions and publishing services for buffer
 * 
 * TODO: Publishing needs to be separated from this service, also a global message
 * does not seem like the best idea, messages should be generated by publishing service
 * that is coordinated by this class.
 */
class RrController : public rclcpp::Node
{
public:
  RrController() : Node("rr_buffer_controller")
  {}

  ~RrController() = default;

  /**
   * @fn init
   * @brief performs initlization, including creating the subscriber.
   */
  void init();


private:
  /**
   * @fn callback
   * @brief callbacks based on timer.
   * 
   * invokes publisher service to publish reponse message.
   */
  void callback();

  // sent timer that will be controlled within this executor.
  rclcpp::TimerBase::SharedPtr timer_;

  // updated for each request taht is sent
  size_t count_ = 0;

  std::shared_ptr<RR_STATE_MAINTAINER_CLASS> state_;
  std::shared_ptr<RR_STATE_BUF_FACTORY_CLASS> factory_;

  // internal initialization methods
  void init_state();
  void init_factory();
};
} // namespace rr_buffer_services

#endif